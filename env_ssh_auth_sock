# If not running interactively, don't do anything
[ -z "${PS1}" ] && return

PID1_NAME=$(ps -p 1 -o comm=)

# If PID 1 is not 'init' or 'launchd', don't do anything
if [ "${PID1_NAME}" != "/sbin/init" ] && [ "${PID1_NAME}" != "/sbin/launchd" ]; then
    return
fi

_SSH_AUTH_SOCK_LOCAL="/tmp/ssh-agent-local-${USER}@$(hostname)"
_SSH_AGENT_STDOUT="/tmp/ssh-agent-local-info-${USER}-$(date | md5sum | cut -d ' ' -f1)"

# 既に SSH_AUTH_SOCK が設定されていて、きちんとソケットとして存在している場合
if [ -n "${SSH_AUTH_SOCK}" ] && [ -S "${SSH_AUTH_SOCK}" ]; then
    if [ -n "${SSH_CONNECTION}" ]; then
        # 環境変数 SSH_AUTH_SOCK と SSH_CONNECTION が空文字ではなく、 SSH_AUTH_SOCK がソケットの場合、ここは SSH 先で Agent Forward されたものなので、名前を付けて保持する
        export SSH_AUTH_SOCK_FORWARD="${SSH_AUTH_SOCK}"
    else
        # それ以外の場合はローカルの ssh-agent のものとして扱う
        ln -sf "${SSH_AUTH_SOCK}" "${_SSH_AUTH_SOCK_LOCAL}"
        export SSH_AUTH_SOCK="${_SSH_AUTH_SOCK_LOCAL}"
        export SSH_AUTH_SOCK_LOCAL="${_SSH_AUTH_SOCK_LOCAL}"
    fi
fi

if [ -S "${_SSH_AUTH_SOCK_LOCAL}" ]; then
    # 既に _SSH_AUTH_SOCK_LOCAL がソケットとして存在している場合は既に起動済みとみなして export するだけ
    export SSH_AUTH_SOCK_LOCAL="${_SSH_AUTH_SOCK_LOCAL}"
else
    # まだ存在していない場合はローカル共用の ssh-agent を起動
    ssh-agent >"${_SSH_AGENT_STDOUT}"
    source "${_SSH_AGENT_STDOUT}" >/dev/null 2>&1 # ここで SSH_AUTH_SOCK が上書きされてしまうので注意

    # んで、 SSH_AUTH_SOCK をシンボリックリンクにして、そっちに向ける
    ln -sf "${SSH_AUTH_SOCK}" "${_SSH_AUTH_SOCK_LOCAL}"
    export SSH_AUTH_SOCK_LOCAL="${_SSH_AUTH_SOCK_LOCAL}"
fi

# Forward 優先で SSH_AUTH_SOCK を設定して終わり
if [ -n "${SSH_AUTH_SOCK_FORWARD}" ]; then
    export SSH_AUTH_SOCK="${SSH_AUTH_SOCK_FORWARD}"
elif [ -n "${SSH_AUTH_SOCK_LOCAL}" ]; then
    export SSH_AUTH_SOCK="${SSH_AUTH_SOCK_LOCAL}"

    # # もし macOS なら keychain 経由での ssh-add をする
    # if [ "${UNAME}" = 'Darwin' ]; then
    #     ssh-add --apple-load-keychain >/dev/null 2>&1
    # fi
fi

unset _SSH_AUTH_SOCK_LOCAL _SSH_AGENT_STDOUT
