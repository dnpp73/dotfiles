# If not running interactively, don't do anything
[ -z "${PS1}" ] && return


# If PID 1 is not 'init' or 'launchd', don't do anything
if [ "${UNAME}" = 'Darwin' ]; then
    # macOS は comm で見る
    if [ "$(ps -p 1 -o comm=)" != "/sbin/launchd" ]; then
        return
    fi
elif [ "${UNAME}" = 'Linux' ]; then
    # それ以外の Unix 系 OS は大抵 init 系のはず。cmd で見る
    if [ "$(ps -p 1 -o comm=)" != "systemd" ] && [ "$(ps -p 1 -o cmd=)" != "/sbin/init" ] && [ "$(ps -p 1 -o cmd=)" != "/sbin/init splash" ]; then
        return
    fi
fi

_SSH_AUTH_SOCK_LOCAL="/tmp/ssh-agent-local-${USER}@$(hostname)"
_SSH_AGENT_STDOUT="/tmp/ssh-agent-local-info-${USER}-$(date | md5sum | cut -d ' ' -f1)"

# 既に SSH_AUTH_SOCK が設定されていて、きちんとソケットとして存在している場合
if [ -n "${SSH_AUTH_SOCK}" ] && [ -S "${SSH_AUTH_SOCK}" ]; then
    if [ -n "${SSH_CONNECTION}" ]; then # SSH_CONNECTION が設定されている場合は Forward
        if [ -z "${SSH_AUTH_SOCK_FORWARD}" ]; then
            export SSH_AUTH_SOCK_FORWARD="${SSH_AUTH_SOCK}"
        fi
    else # SSH_CONNECTION が設定されていない場合は Local
        if [ -L "${_SSH_AUTH_SOCK_LOCAL}" ] && [ -S "${_SSH_AUTH_SOCK_LOCAL}" ] && [ "${_SSH_AUTH_SOCK_LOCAL}" = "${SSH_AUTH_SOCK}" ]; then
            if [ -z "${SSH_AUTH_SOCK_LOCAL}" ]; then
                export SSH_AUTH_SOCK_LOCAL="${_SSH_AUTH_SOCK_LOCAL}"
            fi
        else
            ln -sf "${SSH_AUTH_SOCK}" "${_SSH_AUTH_SOCK_LOCAL}"
            export SSH_AUTH_SOCK_LOCAL="${_SSH_AUTH_SOCK_LOCAL}"
        fi
    fi
fi

if [ -L "${_SSH_AUTH_SOCK_LOCAL}" ] && [ -S "${_SSH_AUTH_SOCK_LOCAL}" ]; then
    # 既に _SSH_AUTH_SOCK_LOCAL がソケットとして存在している場合は既に起動済みとみなして export するだけ
    if [ -z "${SSH_AUTH_SOCK_LOCAL}" ]; then
        export SSH_AUTH_SOCK_LOCAL="${_SSH_AUTH_SOCK_LOCAL}"
    fi
else
    # _SSH_AUTH_SOCK_LOCAL がまだ存在していない場合
    if [ "$(pgrep ssh-agent | wc -l)" -gt 0 ]; then
        _CURRENT_SSH_AGENT_AUTH_SOCK="$(lsof -p "$(pgrep ssh-agent | sort -n | head -1)" -a -U 2>/dev/null | grep unix | tr -s ' ' | rev | cut -d ' ' -f1 | rev)"
        if [ "$(echo "${_CURRENT_SSH_AGENT_AUTH_SOCK}" | wc -l)" -eq 1 ] && [ -S "${_CURRENT_SSH_AGENT_AUTH_SOCK}" ]; then
            ln -sf "${_CURRENT_SSH_AGENT_AUTH_SOCK}" "${_SSH_AUTH_SOCK_LOCAL}"
            export SSH_AUTH_SOCK_LOCAL="${_SSH_AUTH_SOCK_LOCAL}"
        fi
    else
        # ローカル共用の ssh-agent を起動
        ssh-agent >"${_SSH_AGENT_STDOUT}"
        source "${_SSH_AGENT_STDOUT}" >/dev/null 2>&1 # ここで SSH_AUTH_SOCK が上書きされてしまうので注意

        # んで、 SSH_AUTH_SOCK をシンボリックリンクにして、そっちに向ける
        ln -sf "${SSH_AUTH_SOCK}" "${_SSH_AUTH_SOCK_LOCAL}"
        export SSH_AUTH_SOCK_LOCAL="${_SSH_AUTH_SOCK_LOCAL}"
    fi
fi

# Forward 優先で SSH_AUTH_SOCK を設定して終わり
if [ -n "${SSH_AUTH_SOCK_FORWARD}" ]; then
    export SSH_AUTH_SOCK="${SSH_AUTH_SOCK_FORWARD}"
elif [ -n "${SSH_AUTH_SOCK_LOCAL}" ]; then
    export SSH_AUTH_SOCK="${SSH_AUTH_SOCK_LOCAL}"

    # # もし macOS なら keychain 経由での ssh-add をする
    # if [ "${UNAME}" = 'Darwin' ]; then
    #     ssh-add --apple-load-keychain >/dev/null 2>&1
    # fi
fi

unset _SSH_AUTH_SOCK_LOCAL _SSH_AGENT_STDOUT
